# Variable Control (easy)

## Challenge
So far, your buffer overflows have simply set variables to non-zero values. Of course, memory errors often enable significantly more advanced controls over a program's state. In this challenge, you must overflow the buffer precisely to set a win condition variable to a specific value. Some things to keep in mind:

- You will need to write binary data. This can't be printed on the keyboard; we recommend that you use something like Python to produce these bytes.
- Keep endianness in mind!
- Depending on how you generate the input data, you might accidentally terminate it with a newline! For example, bash's `echo` will newline-terminate by default (this behavior can be disabled using the `-n` flag). These newlines can cause problems --- if you are relying on precise control of program variables (which you are, in this module), an errant newline can unexpectedly corrupt program state and break your exploit. If you have doubts about whether your input has an errant newline, save it to a file and look at it using a hex dumper such as `hd`.


## Solve
**Flag:** `pwn.college{caAzGRL5aaBTI4j7ythb_Vhqzjc.QX3UzMzwyNyAzNzEzW}`

#### Gathering Info
The challenge specifies:
- We need to input the answer as binary data. Since it cannot be inputed by keyboard, we are required to pass the input through a script.
- The challenge follows the **little endian**. Therefore, the answer we provide must be reversed to follow the little endian format.
- The input must not contain any *new line characters* since it can unexpectedly corrupt the program state and break our exploit. We can make use of `hd` *hex dumper* to make sure the input file does not contain any *new line characters*.

**Looking through the file given: `binary-exploitation-var-control-w.c` I figure out the following:**
- We are given the following addresses:
    - Buffer start = `...f60` ~ 3936
    - `win` = `...f7c` ~ 3964
    - `lose` = `...f80` ~ 3968
    - saved RBP = `...f90` ~ 3984
- Using these addresses we calculate the variable offsets i.e. the space allocated to each variable:
    - `win` offset = 3964 - 3936 = **28** bytes.
    - `lose` offset = 3968 - 3936 = **32** bytes.
    - saved RBP offset = 3984 - 3936 = **48** bytes.
- Thus, we can deduce that:
    - bytes `0`...`27` are the input buffer (28 bytes long by design).
    - bytes `28`...`31` are the four bytes that hold `win`.
    - bytes `32`...`?` is where `lose` starts (first byte of `lose` is at offset 32).

#### The Goal and the Constrainsts
- Goal: set `win` to the 32-bit value `0x679b4be5`(written in the C file).
- Constraints: **Do NOT** make `lose` non-zero (any non-zero value there triggers program termination).
- Also we do not mess with saved RBP/return address since we want the function to return normally and print the flag.

Therefore: we must write only up through offsets **28...31** to set `win` and stop **before** offset **32** so `lose` stays zero and RBP stays intact. Also, the last 4 bytes matter. We can set the first 28 bytes(the buffer input) any dummy value we want since `win` is only the 4 bytes from **28...31**(inclusive)

#### Endianess
The machine follows little-endian format. It means least-significant byte is stored at the lowest address(first as stack grows downward).

The value `0x679b4be5` is broken into 4 bytes:
- `0x67` `0x9b` `0x4b` `0xe5`

Because of the little-endian memory will contain these bytes in the reverse order:
-    `0xe5` `0x4b` `0x67` `0x9b`
- Thus, we must input these value starting at offset 28.


#### The Safe Payload Length
We want to:

- Fill offsets 0..27 with harmless filler (common: ASCII `A` which is `0x41`) — that’s 28 bytes of filler.
- Then write the 4 bytes `\xe5\x4b\x9b\x67` at offsets 28..31.
- Stop. That’s 32 bytes total.


### Writing the Python Script
```py
from pathlib import Path

payload = b'A' * 28 + bytes([0xE5, 0x4B, 0x9B, 0x67])
Path('payload.bin').write_bytes(payload)
print("wrote payload.bin (32 bytes)")
```
#### The Generated Payload
```
41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41
41 41 41 41 41 41 41 41 41 41 41 41   e5 4b 9b 67
```

#### Passing the Data to the Program
```bash
cat payload.bin | /challenge/./binary-exploitation-var-control-w
```


## New Learnings
- Counting bytes
- Endianess matters
- Identifying offsets


## Resources
- SensAI
- ChatGPT
